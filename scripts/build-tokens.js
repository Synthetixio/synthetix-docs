'use strict';

const path = require('path');
const fs = require('fs');

const snx = require('synthetix');

const network = 'mainnet';
const targets = snx.getTarget({ network });
const synths = snx.getSynths({ network });

const doRounding = (entry, limit) => {
	const num = entry * 2 - limit;

	const decimals = (limit.toString().split('.')[1] || '').length;

	return Number(num).toFixed(decimals);
};

const desc = synth => {
	const underlying = synth.desc.replace(/^Inverted /, '');
	const assetSuffix = synth.name !== underlying ? ` (${synth.asset})` : '';
	if (synth.name === 'sUSD') {
		return 'Tracks the price of a single US Dollar (USD). This Synth always remains constant at 1.';
	} else if (synth.inverted) {
		// Note: indexes can be inverted - so we have this check earlier to show inverted info for inverted indexes
		const { entryPoint, upperLimit, lowerLimit } = synth.inverted;
		return (
			`Inversely tracks the price of ${underlying}${assetSuffix} through price feeds supplied by an oracle. ` +
			`The entry point is $${entryPoint} (the approximate market price at time of creation). ` +
			`This Synth freezes when it reaches its upper limit of $${upperLimit} (i.e. when ${underlying}'s ` +
			`value reaches $${doRounding(
				entryPoint,
				upperLimit,
			)}) or its lower limit of $${lowerLimit} (i.e. when ${underlying}â€™s value ` +
			`reaches $${doRounding(
				entryPoint,
				lowerLimit,
			)}). If it reaches either of its limits and gets frozen, it will no longer be ` +
			'able to be purchased on Synthetix.Exchange, but can still be traded for other Synths at its frozen ' +
			`value. At some point after it has reached either of its limits, it will be substituted for another ${synth.name} with different limits.`
		);
	} else if (synth.index) {
		return (
			`Tracks the price of the index: ${underlying}${assetSuffix} through price feeds supplied by an oracle. ` +
			'This index is made up of the following assets and weights: ' +
			synth.index
				.map(({ symbol, name, units }) => `${units} of ${symbol}${name !== symbol ? ` (${name})` : ''}`)
				.join(', ') +
			'.'
		);
	} else {
		return `Tracks the price of ${underlying}${assetSuffix} through price feeds supplied by an oracle.`;
	}
};

console.log('Building tokens.md');

const tokens = [
	{
		symbol: 'SNX',
		name: 'Synthetix',
		address: targets.ProxySynthetix.address,
		decimals: 18,
		description:
			'The Synthetix Network Token (SNX) gets staked as collateral to back Synths and entitles stakers to receive fees generated by Synth trades on Synthetix.Exchange.',
	},
].concat(
	synths
		.filter(({ category }) => category !== 'internal')
		.map(synth => ({
			symbol: synth.name,
			name: synth.desc,
			address: targets[`Proxy${synth.name}`].address,
			decimals: 18,
			description: desc(synth),
		}))
		.sort((a, b) => (a.symbol > b.symbol ? 1 : -1)),
);

const content = `
# Tokens

${tokens
	.sort((a, b) => (a.name > b.name ? 1 : -1))
	.map(
		({ name, symbol, address, decimals, description }) =>
			`## ${name} (${symbol})\n\n**Address:** [${address}](https://etherscan.io/address/${address})\n\n**Decimals:** ${decimals}\n\n> ${description}\n\n`,
	)
	.join('\n')}

`;
fs.writeFileSync(path.join(__dirname, '..', 'content', 'tokens.md'), content);
